
# Устные вопросы

  

1. Какой самый эффективный способ конкатенации строк?  
	Наиболее эффективным способом является использование структуры Builder из пакета strings, т.к. при использовании метода WriteString минимизируется аллокация памяти, в то время как при использовании оператора + в памяти создается новая строка, а операнды полностью копируются.
1. Что такое интерфейсы, как они применяются в Go?  
      Интерфейс - это набор методов в Go. Позволяет абстрагироваться от реализации метода и дает возможность реализовать полиморфизм в Go. Чтобы какой-либо экземпляр типа в Go реализовывал интерфейс необходимо, чтобы у этого типа были все методы, перечисленные в интерфейсе. 
3. Чем отличаются RWMutex от Mutex?  
      У RWMutex помимо методов Lock() и Unlock() присутствуют методы RLock() и RUnlock(). RWMutex позволяет параллельно записывать и читать данные.
4. Чем отличаются буферизированные и не буферизированные каналы?  
      Наличием буфера. Это влечет за собой наличие кольцевой очереди, хранящей данные у буферизированных каналов (там происходит чтение и запись данных между горутинами), и ее отсутствие у небуферизированных каналов. При взаимодействии через небуферизированные каналы горутины передают данные друг другу напрямую, а канал является средством синхронизации.
    
5. Какой размер у структуры struct{}{}?  
      Пустая структура не занимает место в памяти, поэтому размер - 0.
    
6. Есть ли в Go перегрузка методов или операторов?  
      В Go не существует перегрузки методов в привычном понимании и перегрузки операторов в принципе. Можно использовать дженерики или интерфейсы для обработки параметров неизвестных заранее типов и возвращения значения неизвестных типов.
    
7. В какой последовательности будут выведены элементы map[int]int?  
      
    Пример:
```go
m[0]=1

m[1]=124

m[2]=281  
```
	Элементы могут быть выведены в любой последовательности, т.к. map неупорядоченная структура данных.
	
8. В чем разница make и new?  
      make возвращает экземляр, в то время как new указатель на выделенную память. Кроме того, make инициализирует экземпляр типа данных нулевыми значениями, new возвращает указатель экземпляр с установленным нулевым значением (nil).
    
9. Сколько существует способов задать переменную типа slice или map?  
      Существует 3 способа создать slice или map.
      1. функция make()
      2. функция new()
      3. Литеральная инициализация (стандартный способ создать переменную)
      Автоматически инициализирует slice или map только функция make()
    
10. Что выведет данная программа и почему?  
      
    
```go
func update(p *int) {
  b := 2
  p = &b
}
func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```
	
Программа выведет две единицы. Это объясняется тем, что внутри функции update(p \*int) изменяется лишь локальная переменная p, переменная p из области видимости main никак не затрагивается. 

11. Что выведет данная программа и почему?  
      
    
```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```

Произойдет deadlock, т.к. в горутины, которые создаются циклы передается лишь копия WaitGroup, поэтому метод Done() будет вызываться у копии и метод Wait не дождется завершения горутин и "зануления" счётчика.

12. Что выведет данная программа и почему?  
      
    
```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}  
```
Программа выведет 0, т.к. у блока if true{} собственная область видимости. n внутри этого блока и n внутри функции main - это две разные переменные. Из функции main не видно переменной n из блока условия, поэтому выводится 0. 
13. Что выведет данная программа и почему?  
      
    
```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}
func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}  
```
Вывод программы будет: [100, 2, 3, 4, 5]. В функцию someAction передается срез. Это значит, что, на самом деле, существует возможность изменить этот срез внутри функции someAction, т.к. в переменной v внутри функции при передаче среза будет храниться указатель на массив, на котором образован срез. Поэтому операция v[0] = 100 изменяет исходный массив и, соответственно, срез. Однако переменная v существует лишь внутри функции someAction, поэтому, когда происходит вызов функции append() переменной v присваивается новый срез, но переменная v никак не может повлиять на переменную a, которая находится в main.  

14. Что выведет данная программа и почему?  
      
    
```go
func main() {
  slice := []string{"a", "a"}
  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```
Вывод будет таким: [b b a][a a]. Это объясняется тем, что внутри анонимной функции cоздается локальная переменная slice, которой впоследствии присваивается новый срез (результат работы append), который содержит указатель на другой массив (не тот массив на который указывает slice из main). Далее внутри анонимной функции слайс, который "лежит" на другом массиве изменяется (элементы под индексами 0 и 1). В функции main переменной slice присвоен срез, "лежащий" на исходном массиве, который никак не изменился. 
